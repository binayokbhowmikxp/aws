Methods For Encrypting Application Data
There are multiple strategies for ensuring that data processed and generated by an application ends up in an encrypted state on disk.

Applications and underlying infrastructure services will leverage the following concepts:

Key Management Service and Encryption Keys
Refer to a key management service to determine which encryption key will be used to encrypt the data.

AWS provides a key management service called KMS which is tightly integrated with the AWS services and the AWS SDKs that a developer would be using.

Client-Side Encryption
You can choose to encrypt the data within the application prior to persisting or writing. We will loosely refer to this as client-side encryption.

Server-Side or AWS Service native encryption
Alternatively, have the AWS service handle the underlying encryption activities. We can refer to this broadly as server-side encryption.


scenario1
----------
Writing Data to Disk With Client-Side Encryption

An application may write data to a disk mount such as an EBS volume or EFS mount. The application can use AWS SDKs and the KMS service to encrypt a file prior to writing to disk.

Once a data encryption key is obtained, Developers can choose to use language native encryption libraries. They can also leverage the AWS SDK to go through the encryption process. The AWS SDK helps by encapsulating many of the steps required to encrypt and store the data.

scenario2
---------

Using Encrypted Disk Volumes in AWS
On the infrastructure side we need to ensure that disk volumes are configured to use KMS encryption so that the entire disk remains encrypted regardless of the fact that the application chooses to encrypt or not.

The EC2 Service can obtain a data encryption key from KMS. The encryption key is based on a master key that the EBS volume is associated with.

The data encryption key is then used by the hypervisor to ensure that all I/O operations result in encrypted data on disk. Write operations will use the key to encrypt and read operations will use the key to decrypt.

The hypervisor will make the data available and decrypted to the instance operating system.


scenario3
---------

Writing Data to a Database Table
The same concept we looked at for encrypting file data on disk volumes applies to databases too. The application should encrypt sensitive data prior to storing the record value in the database, using the encryption SDKs. On the platform service or server-side, we need to ensure that encryption is enabled when provisioning the database platform of choice (e.g. RDS, DynamoDB etc).

scenario4
---------

Writing Data to Object Storage, such as S3
Highly sensitive data should be encrypted by the application prior to putting an object in S3. In this case, because we use client-side encryption from within the application code and encryption SDK, S3 will not be aware about the encryption.

In the case of S3, the application code can also set parameters for server-side encryption so that the S3 service will handle the encryption for the particular objects. S3 buckets can also be configured to have default server-side encryption enabled for all new objects. In this case encryption is transparent to the application code.

As a best practice we want to ensure that S3 server-side encryption is enabled by default where possible.

---------------------------
+Client-Side vs.Server-Side+
----------------------------

Client-Side Encryption
Pros
The cloud provider, that is AWS, or anyone with access to the underlying disk volumes will only see ciphered or encrypted data. The data is effectively useless to them unless of course they have permissions or access to the encryption keys.

Cons
The code will have additional complexity of using SDK's and libraries required to perform cryptographic functions. Some additional understanding of encryption is also needed to do this effectively. There is always the potential of this additional functionality being inadvertently omitted from the code .

Server-Side Encryption
Pros
For most use cases server-side encryption can be completely transparent to the developer or application code. So, from an implementation perspective, it is simpler and easier to use.

Cons
Anyone with read access permissions to the service in question will perform a read and be able to see the plain text data.

Best Practices
As a best practice it is highly advisable to leverage server-side encryption as a default deployment pattern for any AWS services being used to store data.

The decision to use client-side encryption in your applications may be made on a case-by-case basis for sensitive data or to meet any compliance requirements.



++++++++++++++++++++++++++++++++++++++
+Using The AWS Key Management Service+
++++++++++++++++++++++++++++++++++++++

Let's look at a few options and best practices for ensuring that encryption keys themselves are managed securely using the AWS Key Management Service. KMS provides multiple avenues for creating CMKs. It is important to understand the difference between these options.

AWS-Managed Customer Master Keys
--------------------------------
This is the default and easiest type of KMS key to use. It requires very little management and no cost on the part of the customer.

The key is provisioned automatically by KMS when a service such as S3 or EC2 needs to use KMS to encrypt underlying data. A separate master key would be created for each service that starts using KMS.

Permissions to AWS managed keys are also handled behind the scenes. Any principal or user who has access to a particular service would inherently have access to any encrypted data that the service had encrypted using the AWS managed keys.

Using an example of a DynamoDB table that has encryption using AWS managed keys, all users or roles in the account that have read access to the dynamodb table would be able to read data from the table.

With this method key rotation is also handled behind the scenes by AWS and keys are rotated every 3 years.

This approach is acceptable if the sole requirement is to ensure that data is encrypted at rest in AWS' data centers.

Limitations With AWS Managed CMKs
---------------------------------

The main drawback here is that it does not allow granular and least privileged access to the keys. It would not be possible to segment and isolate permissions to certain keys and encrypted data. In addition to this limitation, AWS managed keys are not available for applications to use for client-side encryption since they are only available for use by AWS services.

This approach is also not recommended for accounts where sensitive data is present since in the event of the AWS account or role compromised for some reason, encrypted data may not be protected.



Customer-Managed Customer Master Keys
-------------------------------------

The second option is to explicitly provision the keys using KMS. In this case the user creates and manages permissions to the keys.

AWS will create the key material and rotate keys on a yearly basis, and the user does have the option to choose to manually rotate keys.

The main benefit to this approach is that permissions to manage and use the keys can be explicitly defined and controlled. This allows separation of duties, segmentation of key usage etc.

Again using DynamoDB as an example, we can have much more flexibility to restrict access to data by restricting access to encryption keys. For example we can have 2 separate master keys, for two different sets of tables or data classifications, for example non-sensitive and sensitive tables. We can also assign certain IAM roles to be able to use the keys, and other IAM roles to be able to manage the keys.

This second approach is a good balance between manageability and security, and it will generally provide the capabilities mandated by most compliance standards.

KMS also provides the ability for the user to create master key material outside of AWS and import it into KMS.

Bring Your Own Key
------------------

When new customer master keys are provisioned in KMS, by default, KMS creates and maintains the key material for you. However, KMS also provides the customer the option of importing their own key material which may be maintained in a key store external to KMS. With this option the customer has full control of the key's lifecycle including expiration, deletion, and rotation.

A potential use case for importing key material may be to maintain backup copies of the key material external to AWS to fulfill disaster recovery requirements. Customers may also find this option useful if they have a desire to use one key management system for cloud and on-premise infrastructure.

+++++++++++
+Key Terms+
+++++++++++

Key Rotation
------------

The process of changing data encryption keys used for cryptographic operations on a periodic basis.

Customer Master Key (CMK)
-------------------------

The customer master key is the master encryption key that will be used to encrypt and store underlying data encryption keys in the KMS service. Other services or applications will select a CMK to use for their cryptographic operations.

AWS-Managed CMK
---------------

AWS-managed customer master keys are provisioned, rotated and managed by AWS. AWS will provision a new master key for each AWS service in the AWS account at the time the service needs to start encrypting data. These keys are not available to use by your applications for client-side encryption.

You may not change or assign permissions on these keys.

Customer-Managed CMK
--------------------

Customer managed master keys are provisioned and managed by the customer (you). Once you provision a key, you may use that key with any AWS services or applications.

You can manage permissions on customer managed CMKs to control which IAM users or roles can manage or use the encryption keys. Permissions to use the keys can also be granted to AWS services and other AWS accounts.
